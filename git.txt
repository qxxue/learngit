git story:
安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。
开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控
工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。
Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：
Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由
Git管理了！牛是怎么定义的呢？大家可以体会一下。
Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储
，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。
历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。

git跟svn的差别:
git:分布式,本地有镜像,无网络时也可以提交到本地镜像,待到有网络时再push到服务器.
svn:非分布式.无网络不可以提交.

那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”
，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的
电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，
你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方
的修改了。
和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，
某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要
是出了问题，所有人都没法干活了。
在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不
在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式
版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改
，没有它大家也一样干活，只是交换修改不方便而已。

Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。
CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会
造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，
是目前用得最多的集中式版本库控制系统。
除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购
了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特
点是财大气粗，或者人傻钱多。
微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都
不好意思用了。
分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分
布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！

Q:如果两个人都是改同一个文件里的同一句代码呢，是否会产生冲突。使用Git遇到冲突要如何解决？
A:会产生冲突，但是两个人改的代码都在 通过header 来区分是谁写的之后 你们在手动解决冲突就行，由于
我们改代码的时候很小心(提前知会)，几乎没有冲突。

Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。
要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：
在Linux上安装Git
首先，你可以试着输入git，看看系统有没有安装Git：

在Windows上安装Git
在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选
项安装即可。
安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！
安装完成后，还需要最后一步设置，在命令行输入：
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，
如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的
也是有办法可查的。
注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，
当然也可以对某个仓库指定不同的用户名和Email地址。

创建版本库:
	什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所
有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在
将来某个时刻可以“还原”。所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：
	$ mkdir learngit	#cd d:  #create at d:
	$ cd learngit
	$ pwd			#pwd命令用于显示当前目录
如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。
第二步，通过git init命令把这个目录变成Git可以管理的仓库：
$ git init
瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前
目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文
件，不然改乱了，就把Git仓库给破坏了。
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。
也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议使用自己正在
开发的公司项目来学习Git，否则造成的一切后果概不负责。

把文件添加到版本库:
首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程
序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第
8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文
件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本
控制系统不知道，也没法知道。
不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我
们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。
因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议
使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。
使用Windows的童鞋要特别注意：千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开
发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了
0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明
正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本
，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：

CS: dir--> ls; $ls --help;  $ls -ah  (guess: long option with --, short option with -)

自己写的档案一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也
找不到这个文件。然后要放到仓库：
第一步，用命令git add告诉Git，把文件添加到仓库：
	$ git add readme.txt		#git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：
执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。
第二步，用命令git commit告诉Git，把文件提交到仓库：
	$ git commit -m "wrote a readme file"
	简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义
	的，这样你就能从历史记录里方便地找到改动记录。
	嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自
	己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。
	git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（新添加的readme.txt文件）；
	2 insertions：插入了两行内容（readme.txt有两行内容）。

初始化一个Git仓库，使用git init命令。
添加文件到Git仓库，分两步：
	使用命令git add <file>，注意，可反复多次使用，添加多个文件；
	使用命令git commit -m <message>，完成。
	
克隆现有的仓库
如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就
要用到 git clone 命令。 如果你对其它的 VCS 系统（比如说Subversion）很熟悉，请留心一下你所使用的
命令是"clone"而不是"checkout"。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 
Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的
时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的
磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器
端的挂钩设置，但是所有版本的数据仍在，详见 在服务器上搭建 Git ）。
克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：
	$ git clone https://github.com/libgit2/libgit2
	这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓
	库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。
	如果进入到这个新建的 libgit2 文件夹，会发现所有的项目文件已经在里面了，准备就绪等待后续的
	开发和使用。
如果想在克隆远程仓库的时候，自定义本地仓库的名字，可以使用如下命令：
	$ git clone https://github.com/libgit2/libgit2 mylibgit
	这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。

Git 支持多种数据传输协议。上面的例子使用的是 https:// 协议，不过也可以使用 git:// 协议或者使用
SSH 传输协议，比如 user@server:path/to/repo.git 。 在服务器上搭建 Git 将会介绍所有这些协议在服务器
端如何配置使用，以及各种方式之间的利弊。

Q:[git] warning: LF will be replaced by CRLF | fatal: CRLF would be replaced by LF
	https://blog.csdn.net/feng88724/article/details/11600375

每当觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦把文件
改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部
丢失。
	历史日I记录，在Git中，用git log命令查看，可以试试加上--pretty=oneline参数：到的一大串类似
	1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个
	SHA1计算出来的一个非常大的数字，用十六进制表示

准备把readme.txt回退到上一个版本，首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版
本，提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写
100个^比较容易数不过来，所以写成HEAD~100。把当前版本append GPL回退到上一个版本newly created，就可
以使用git reset命令：
	$ git reset --hard HEAD^	#HEAD^处也可以写版本号ID
	版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多
	个版本号，就无法确定是哪一个了。
	因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：
	然后顺便把工作区的文件更新了。所以HEAD指向哪个版本号，把当前版本定位在哪。
	CS:工作区的notepad有显示回到以前版本并询问是否更新
查看内容：是否上个版本内容？
	$ cat readme.txt

若反悔想恢复到新版本怎么办？找不到新版本的commit id怎么办？
在Git中，总是有后悔药可以吃的。用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复
就必须找到该版本的commit id。Git提供了一个命令git reflog用来记录每一次命令：
	$ git reflog

总结一下：
	HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令
	git reset --hard commit_id。
	穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
	要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。
	
工作区（Working Directory）：
	就是在电脑里window下dir能看到的目录，比如learngit文件夹就是一个工作区：

版本库（Repository）：
	工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
	Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为
	我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。（CS图见档案python 语法）
	第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
	第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
	因为创建Git版本库时，Git自动创建了唯一一个master分支，所以，现在，git commit就是往master分支
	上提交更改。
	可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。
	$ git status	#非常清楚显示，被修改未被commit的档案，还从来没有被添加过所以它的状态是	Untracked， 
	显示：	On branch master
			nothing to commit, working tree clean
小结：stage暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。
	stage 中拥有着 和 working directory 中一模一样 的 目录结构、文件内容;
	stage: It's not technically a tree structure, it's a flattened manifest, but for our purposes it's close enough.
	暂存区的文件目录和最近一次git add之后工作区的文件目录是一致的，因此当修改完文件使用git diff
	可以看到工作区和暂存区的差异（此时暂存区是上一次add之后的目录，而工作区是刚修改完的样子），
	使用git add加入新的修改，再git diff就不会有输出，因为暂存区被更新为最新的工作区目录。
	git diff --cached同理，只是比较的是暂存区和分支里的内容差异（分支保持上一次git commit的目录）。
	$git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）
	$git diff --cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



